import { NextRequest, NextResponse } from 'next/server'
import fs from 'fs'
import path from 'path'
import archiver from 'archiver'

const WORKSPACE_ROOT = path.join(process.cwd(), 'generated-projects', 'workspace')

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const projectName = searchParams.get('project')

    if (!projectName) {
      return NextResponse.json(
        { error: 'Project name is required' },
        { status: 400 }
      )
    }

    const projectPath = path.join(WORKSPACE_ROOT, projectName)

    if (!fs.existsSync(projectPath)) {
      return NextResponse.json(
        { error: 'Project not found' },
        { status: 404 }
      )
    }

    const buildReceipt = `# Build Receipt - ${projectName}

Generated: ${new Date().toISOString()}

## Project Structure
${generateProjectStructure(projectPath)}

## Installation
\`\`\`bash
npm install
\`\`\`

## Development
\`\`\`bash
npm run dev
\`\`\`

## Build
\`\`\`bash
npm run build
\`\`\`

---
Generated by NexaBuilder AI
`

    const receiptPath = path.join(projectPath, 'BUILD_RECEIPT.md')
    fs.writeFileSync(receiptPath, buildReceipt)

    const archive = archiver('zip', {
      zlib: { level: 9 },
    })

    const chunks: Uint8Array[] = []

    archive.on('data', (chunk) => {
      chunks.push(chunk)
    })

    await new Promise<void>((resolve, reject) => {
      archive.on('end', () => resolve())
      archive.on('error', (err) => reject(err))

      archive.directory(projectPath, projectName)
      archive.finalize()
    })

    const buffer = Buffer.concat(chunks)

    return new Response(buffer, {
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': `attachment; filename="${projectName}.zip"`,
      },
    })
  } catch (error) {
    console.error('Error creating download:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to create download' },
      { status: 500 }
    )
  }
}

function generateProjectStructure(dir: string, prefix = '', isLast = true): string {
  let structure = ''
  
  if (!fs.existsSync(dir)) {
    return structure
  }

  const items = fs.readdirSync(dir).filter(item => 
    !item.startsWith('.') && item !== 'node_modules' && item !== 'BUILD_RECEIPT.md'
  )
  
  items.forEach((item, index) => {
    const isLastItem = index === items.length - 1
    const fullPath = path.join(dir, item)
    const stat = fs.statSync(fullPath)
    
    structure += `${prefix}${isLastItem ? '└── ' : '├── '}${item}\n`
    
    if (stat.isDirectory()) {
      const newPrefix = prefix + (isLastItem ? '    ' : '│   ')
      structure += generateProjectStructure(fullPath, newPrefix, isLastItem)
    }
  })
  
  return structure
}
